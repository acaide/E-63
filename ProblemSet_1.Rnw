\documentclass{report}

\usepackage{Sweave}
\usepackage{longtable}
\usepackage{rotating}
\usepackage{color}
\usepackage[bookmarks=true]{hyperref}
\usepackage{graphics}
\usepackage{xcolor}   % Color package for text colors
\usepackage{fancyhdr} % For Footer und Header
\usepackage{lastpage} % For labeling pages
\usepackage{longtable}
\usepackage{pdflscape}
\usepackage{amsmath}
\usepackage{mathabx}
\usepackage{indentfirst} % indents please
\usepackage{listings} %line-listing codes!!

\begin{document}
\SweaveOpts{concordance=TRUE}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Title page
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{titlepage}
\begin{center}
\vspace{2cm}
--------------------------------------------------------------------------------------------------- \\
\begin{LARGE}
\vspace{1.2cm}
\emph{Problem Set 1} \\
\textbf{Introduction to R\\
        E63 Big Data Analytics}\\
\vspace{1.2cm}
\end{LARGE}
--------------------------------------------------------------------------------------------------- \\
\vspace{3cm}
\begin{large}
  \textbf{Harvard Extention School}\\
  \emph{Andrew Caide}\\
 \vspace{0.8cm}
  \today \\
  Problem Set 1\\
\end{large}
--------------------------------------------------------------------------------------------------- \\
\end{center}
\end{titlepage}
\clearpage



\tableofcontents
\thispagestyle{fancy}
<<standardFunctions, echo=FALSE, hide=TRUE, results=hide>>=
#rm(list=ls())
# Sanitize function for print.xtable()
my.sani <- function (x){
	x <- gsub("%NRBC >= 2%", "2 <= %NRBC < 15", x, fixed = TRUE)
	x <- gsub("<=", "$\\leq$", x, fixed = TRUE)
	x <- gsub(">=", "$\\geq$", x, fixed = TRUE)
	x <- gsub(">", "$>$", x, fixed = TRUE)
	x <- gsub("<", "$<$", x, fixed = TRUE)
	x <- gsub("_", "-", x, fixed = TRUE)
	x <- gsub("%", "$\\%$", x, fixed = TRUE)
	x <- gsub("subset", "$ \\subset$", x, fixed = TRUE)
	x <- gsub("µ", "$\\mu$", x, fixed = TRUE)
	x <- gsub("^", "$\\wedge $", x, fixed = TRUE)
	x <- gsub("10$\\wedge $3", "$10^3$", x, fixed = TRUE)
	x <- gsub("10$\\wedge $6", "$10^6$", x, fixed = TRUE)
	x <- gsub("#", "\\#", x, fixed = TRUE)
	x <- gsub("*", "$\\cdot$ ", x, fixed = TRUE)
	x <- gsub("$ $", "$$", x, fixed = TRUE)
	x <- gsub("[", "$[$", x, fixed = TRUE)
	return(x)
}

# for tables longer than one page in print.xtable()
addtorow <- list(pos=list(c(0)),
				 command=c(paste("\\hline \n", "\\endhead \n", "\\hline \\multicolumn{2}{l} \n",
						"{Continued on next page} \n", "\\endfoot \n", "\\endlastfoot \n",sep="")))
@

\chapter{Problem Set Questions}
\thispagestyle{fancy}

\section{Problem 1}
\thispagestyle{fancy}
\vspace{5mm} 
Binomial distribution describes coin tosses with potentially doctored or altered coins. Value of p is the probability that head comes on top. If both the head and the tail have the same probability, p = 0.5. If the coin is doctored or altered, p could be larger or smaller. Plot on three separate graphs the binomial distribution for p = 0.3,        p = 0.5 and p = 0.8 for the total number of trials n = 60 as a function of k, the number of successful (head up) trials. Subsequently, place all three curves on the same graph. For each value of p, determine 1st Quartile, median, mean, standard deviation and the 3rd Quartile. Present those values as a vertical box plot with the probability p on the horizontal axis.   
(15\%)
 

\section{Problem 2}
\vspace{5mm} 
\textbf{Problem 2}. Finish the plot of the correlation between waiting times and durations of Old Faithful data. Recreate the scatter plot of waiting vs. duration times. As we mentioned in class, the best linear assessment in the sense of the least squares fit of a relationship (proportionality) between two or many variables can be achieved with R function lm(). lm stands for the linear model. The first argument of lm() is called formula accepts a model which starts with the response variable, waiting in our case, followed by a tilde (symbol ~, read as “is modeled as”) followed by the (so called Wilkinson-Rogers) model on the right. In our case we simply assume that waiting time is proportional to the duration time and that “model” reads: formula = waiting ~ duration. The second argument of function lm() is called data and, in our case, will take value faithful, the data set containing our data. Store the result of function lm() in a variable. The name of that variable is not essential. Call it model. Print the variable. The first component of that variable is the intercept of calculated line with the vertical axis (waiting, here) and the second is the slope of the line. Convince yourself that line with those parameters will truly lie on your graph. Function abline() adds a line to the previously created graph. Next, pass the variable model to the function abline(). Make that line somewhat thicker and blue. Use help(functionName) to find details about invocations of both lm() and abline() functions. 
(20\%)


\section{Problem 3}
\vspace{5mm} 
Calculate the covariance matrix of the faithful data. Determine the eigenvalues and eigenvectors of that matrix. Demonstrate that two eigenvectors are mutually orthogonal. Demonstrate that the eigenvector with the larger eigenvalue is parallel with line discovered by lm() function it the previous problem. 
(15\%)


\section{Problem 4}
\vspace{5mm} 
You noticed that eruptions clearly fall into two categories, short and long. Let us say that short eruptions are all which have duration shorter than 3.1 minute. Add a new column to data frame faithful called type, which would have value ‘short’ for all short eruptions and value ‘long’ for all long eruptions. Next use boxplot() function to provide your readers with some basic statistical measures for waiting. In a separate plot present the box plot for duration times. Please note that boxplot() function also accepts as its first argument a formula such as waiting ~ type, where waiting is the numeric vector of data values to be split in groups according to the grouping variable type. The second argument of function boxplot() is called data, which in our case will take the name of our dataset, i.e. faithful. Find a way to add meaningful legends to your graphs. Subsequently, present both boxplots on one graph.
(20\%)


\section{Problem 5}
\vspace{5mm} 
reate a matrix with 40 columns and 100 rows. Populate each column with random variable of the uniform distribution type. Make those distributions symmetric around zero. Let the distribution for each column appear like the one on slide 92 of the lecture note, except centered around zero.  Present two distributions contained in any two randomly selected columns of your matrix on two separate plots. Convince yourself that generated distributions are (close to) uniform.
(15%)
 

\section{Problem 6}
\vspace{5mm} 
Start with your matrix from problem 5. Add yet another column to that matrix and populate that column with the sum of original 40 columns. Create a histogram of values in the new column showing that the distribution starts to resemble the Gaussian curve. Add a true, calculated, Gaussian curve to that diagram with the parameters you expect from the sum of 40 random variables of uniform distribution with values between -1 and 2. 
(15\%)



\section{Document History}
\thispagestyle{fancy}
\begin{itemize}
  \item September 2 2017: first draft document
\end{itemize}


\chapter{Solutions}
\clearpage
\section{Problem 1}
This question explores binomial distributions with different weights (or probabilities). A set of results that are binomially distributed have only two results, like a coin flip (heads or tails).\\
Firstly we explore what a weighted distribution looks like, with three weights: 0.3 (20\% lower success rate  ), 0.5 (equally weighted), and 0.8 (30\% higher success rate). 

\begin{figure}[h]
 \begin{center}
<<Problem1, echo=FALSE, quiet=TRUE, results=tex, fig=TRUE>>=

# Load libraries
library(ggplot2)   # for plots
library(mWeave)    #everything
library(xtable)    #latex tables
library(gridExtra) # multiple gg plots in same page
library(plyr) #for that one use of ddply

quartile.compute = function(x){ #Input: The (already subsetted) vector
  quant = quantile(x)
  return(data.frame(LowerQuartile = quant[2], UpperQuartile = quant[4]))
}

#####
# Problem 1: 
#Binomial distribution describes coin tosses with potentially doctored or altered coins.
#Value of p is the probability that head comes on top. If both the head and the tail have the same probability, p = 0.5.
#If the coin is doctored or altered, p could be larger or smaller.

#Plot on three separate graphs the binomial distribution for p = 0.3, p = 0.5 and p = 0.8 for the total number of trials n = 60 as a function of k, the number of successful (head up) trials.

#Subsequently, place all three curves on the same graph.

#For each value of p, determine 1st Quartile, median, mean, standard deviation and the 3rd Quartile.

#Present those values as a vertical box plot with the probability p on the horizontal axis.

#####
# Code:

set.seed(10111990)

# Set conditions
n <- 60
P1 <- 0.3
P2 <- 0.5
P3 <- 0.8

vector <- c(1:n)

# For simple density plots - "d" for density
binom1 <- dbinom(vector, n, P1)
binom2 <- dbinom(vector, n, P2)
binom3 <- dbinom(vector, n, P3)

# For experimental trials - "r" for randomly generated values with given distribution
values1 <- rbinom(vector, n, P1)
values2 <- rbinom(vector, n, P2)
values3 <- rbinom(vector, n, P3)

# Form data frame and plot for simple density plot
df <- data.frame("k" = vector, "Pk" = binom1, "Probability" = "0.3")
df <- rbind(df, data.frame("k" = vector, "Pk" = binom2, "Probability" = "0.5"))
df <- rbind(df, data.frame("k" = vector, "Pk" = binom3, "Probability" = "0.8"))


# Individual Density Plots
p1 <- ggplot(data=df[which(df$Probability==0.3),], aes(x=k, y=Pk))+
    geom_line()+
    labs(title = "Density plot for P(k) = 0.3", y = "P(k)", x="",
       color = "0.3")+
    theme_bw()         #turn off grey grid

p2 <- ggplot(data=df[which(df$Probability==0.5),], aes(x=k, y=Pk))+
   geom_line()+
      labs(title = "P(k) = 0.5", y = "P(k)", x="",
       color = "0.3")+
  theme_bw()         #turn off grey grid
p3 <- ggplot(data=df[which(df$Probability==0.8),], aes(x=k, y=Pk))+
   geom_line()+
      labs(title = "P(k) = 0.8", y = "P(k)", x="k",
       color = "0.3")+
  theme_bw()         #turn off grey grid
   
grid.arrange(p1,p2,p3)


@
  \caption{Question 1, Individual Density Plots of Binomial distributions of three trials where n = 60.}
 \end{center}
\end{figure}

To confirm the distributions in Figure 2.1, we can recall the mean of a binomial distribution:

\[ \mu_k = np \]

where \(\mu_k\) is the mean (on k axis), with probability p, and n number of trials.  Furthermore binomial distributions have a variance:

\[ \sigma^2_k = np(1-p) \]

where \(\sigma^2_k\) is the standard deviation. It should be noted that as the probability increases the variance tightens as the probability increases. An eyeball test indicate our plots were spot on:            \(\mu_k\{0.3, 0.5, 0.8\} = 60*\{0.3, 0.5, 0.8\} = \{18, 30, 48\} \). 

Before moving on, I would like to use histograms for the next plot because coinflip measurements are discrete: there's no way somebody could have obtained 15.3 heads + 0.7 tails.The plot will have 60 bins, one per possible outcome (n = 60). It should also be noted that the probability values are going to appear greater - they should. The (continuous) density plots weigh the probability on all space, including invalid results. Now that the results have made discrete the likelihood of outcomes should look a lot more reasonable.

\begin{figure}[h]
 \begin{center}
<<Problem11, echo=FALSE, quiet=TRUE, results=tex, fig=TRUE>>=
# Histogram Plot/All three cumulatives.
## Make Bar-Plot values
df2 <- data.frame("Value" = values1, "Probability" = "0.3")
df2 <- rbind(df2,data.frame("Value" = values2, "Probability" = "0.5"))
df2 <- rbind(df2,data.frame("Value" = values3, "Probability" = "0.8"))

p <- ggplot(df2, aes(x=Value, fill=Probability)) + 
  geom_histogram(aes(y=..density..), alpha=0.2, position="identity", col = "grey", bins=60) +
  labs(title = "Histogram for the Three Weights", x = "Value of Outcome", 
       y = "Likelihood of Outcomes", 
       color = "Weights\n")+
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"))+
  theme_bw()

print(p)


###########################################
#
# Summary table of the bar-plot statistics!

# This is very sloppy and lazy, but I can't figure a good "apply" alternative :\\
quartile.bind <- quartile.compute(df2[which(df2$Probability=="0.3"),1])
quartile.bind <- rbind(quartile.bind, quartile.compute(df2[which(df2$Probability=="0.5"),1]))
quartile.bind <- rbind(quartile.bind, quartile.compute(df2[which(df2$Probability=="0.8"),1]))
rownames(quartile.bind) <- c("0.3", "0.5", "0.8")

# But for some reason this works??? 
sum.tab <- ddply(df2,~Probability,summarise,Mean=mean(Value),SD=sd(Value), Median = median(Value))
sum.tab <- cbind(sum.tab, quartile.bind)
sum.tab <- sum.tab[,c(1,5,4,2,3,6)] #Cleaning


xtab <- xtable(sum.tab, caption=paste("Summary of Question 1 Data. Length of data set, 25 Percent quartile, Mean, Median, Standard Deviation, and 75 Percent quartile.", sep=""), 
               align="|r|r|rrrrr|", digits = 0)
print(xtab, file="q1.tex", table.placement = "h",
      sanitize.text.function=my.sani, include.rownames = FALSE, floating = FALSE,
		hline.after=c(-1,0,nrow(xtab)), tabular.environment="longtable",
		add.to.row=addtorow, caption.placement="top")


@
  \caption{Question 1, Binomial distributions of three trials where n = 60.}
 \end{center}
\end{figure}

The summary of the binomial statistics are outlined in the following table, and boxplots on figure 2.3 further illustrate the median, 25\% and7\% quartiles, and the max and min.

\input{q1.tex}


\begin{figure}[h]
 \begin{center}
<<Problem12, echo=FALSE, quiet=TRUE, results=tex, fig=TRUE>>=

plot2 <- ggplot(data = df2, aes(y=Value, x = Probability, fill = Probability)) + 
  geom_boxplot() +
  labs(title = "Binomial Distribution Boxplots. Results vs Likelihoods.", y = "Results", 
       color = "Probabilities\n")+
  theme_bw()         #turn off grey grid

print(plot2)

@
  \caption{Question 1, Box Plots for the Binomial Distributions. Statistics outlined in aforementioned table.}
 \end{center}
\end{figure}


\clearpage
\section{Problem 2}

This question investigates the relationship of two measures in the 'faithful' built in data-set. This data set comes from the Old Faithful Geyser in Yellowstone National Park, USA. Two measures will be examined in this data set: the time between geyser eruptions (in minutes), and the duration of the eruptions (in minutes). First we look at the data on a scatter-plot and see if we can apply a linear fit with a reasonable correlation.

\begin{figure}[h]
 \begin{center}
<<Problem2, echo=FALSE, quiet=TRUE, results=tex, fig=TRUE>>=

#####
# Problem 2:
#Finish the plot of the correlation between waiting times and durations of Old Faithful data.
#Recreate the scatter plot of waiting vs. duration times.
#As we mentioned in class, the best linear assessment in the sense of the least squares fit of a relationship (proportionality) between two or many variables can be achieved with R function lm(). lm stands for the linear model.
#The first argument of lm() is called formula accepts a model which starts with the response variable, waiting in our case, followed by a tilde (symbol ~, read as “is modeled as”) followed by the (so called Wilkinson-Rogers) model on the right.
#In our case we simply assume that waiting time is proportional to the duration time and that “model” reads: formula = waiting ~ duration. The second argument of function lm() is called data and, in our case, will take value faithful, the data set containing our data.
#Store the result of function lm() in a variable. The name of that variable is not essential. Call it model. Print the variable.
#The first component of that variable is the intercept of calculated line with the vertical axis (waiting, here) and the second is the slope of the line.

#Convince yourself that line with those parameters will truly lie on your graph. Function abline() adds a line to the previously created graph. Next, pass the variable model to the function abline(). Make that line somewhat thicker and blue. Use help(functionName) to find details about invocations of both lm() and abline() functions.

#####
# Code:

## Stole this from somebody on the internet a long time ago. Good stuff
lm_eqn <- function(df){
    m <- lm(y ~ x, df);
    eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
         list(a = format(coef(m)[1], digits = 2), 
              b = format(coef(m)[2], digits = 2), 
             r2 = format(summary(m)$r.squared, digits = 3)))
    as.character(as.expression(eq));                 
}
##

df <- faithful

lin.mod <- lm(data = df, formula = waiting ~ eruptions)
intercept = lin.mod$coefficients[1]
slope = lin.mod$coefficients[2]

colnames(df) <- c("x","y")
p <- ggplot(data = df, aes(x = x, y = y))+ #+
  geom_point() +
  geom_abline(intercept = intercept, slope = slope, color = "lightblue", size=4)+
  geom_smooth(method = "lm", se = FALSE, linetype="dotted", color = "red")+
    labs(title = "Faithful: Duration of Eruptions vs Waiting Time between Eruptions", 
         x = "Eruption Duration (mins)", y = "Waiting Time (mins)",
         color = "Linear Model")+
  theme_bw() + geom_text(x = 2.5, y = 90, label = lm_eqn(df), parse = TRUE)

print(p)

@
  \caption{Question 2, Linear Fit on Faithful Data}
 \end{center}
\end{figure}

Fhe linar fit constructed from the lm() function is shown in blue. To verify, I allowed ggplot to apply its fit (without additional input), indicated by the red dots. The correlation coefficient is weak at \(r^2 = 0.811\). 



\section{Problem 3}

This problem revisits the faithful data. In the previous question we found ourselves unsatisfied with the correlation coeficient from the linear plot, but the plot certainly indicates two populations of events. Let's take a more rigorous look.\\

<<Problem3, echo=FALSE, quiet=TRUE, results=tex>>=

#####
# Problem 3.

#1 Calculate the covariance matrix of the faithful data. Determine the eigenvalues and eigenvectors of that matrix.
#2 Demonstrate that two eigenvectors are mutually orthogonal.
#3 Demonstrate that the eigenvector with the larger eigenvalue is parallel with line discovered by lm() function it the previous problem.
#####

df <- faithful

covariance <- cov(df)
xtab <- xtable(covariance, caption=paste(" Covariance result.", sep=""), 
               align="rc|c", digits = 0)
print(xtab, file="covar.tex", table.placement = "h",
      sanitize.text.function=my.sani, include.rownames = FALSE, floating = FALSE,
		hline.after=c(-1,0,1,nrow(xtab)), tabular.environment="longtable",
		add.to.row=addtorow, caption.placement="top")
eig <- eigen(covariance)
eig.values <- eig$values
eig.vectors <- eig$vectors

orthogonality <- crossprod(eig.vectors)

@


First let's observe the covariance of the faithful data.
\begin{lstlisting}[language=R]
> df <- faithful
> covariance <- cov(df)
> covariance # See table
\end{lstlisting}
\input{covar.tex}

The positive covariance between eruption durations and waiting times idicates a positive relationship between the two variables, which was already made fairly obvious. It is safe to ignore the diangonols in this matrix. Note: a covariance of 0 should indicate no relationsip, and the magnitude of the covariance indicates a stronger relationship. Therefore a covariance of -130 indicates a tight (or relatively stronger than our 13.98), but negatively trending relationsip.  \\

From this we can calculate the eigen values and eigen vectors.

\begin{lstlisting}[language=R]
> eig.values <- eig$values
eigen.values

[1] 185.8818239   0.2442167

> eig.vectors <- eig$vectors
> eig.vectors

           [,1]       [,2]
[1,] -0.9885959 -0.1505924
[2,]  0.1505924 -0.9885959
\end{lstlisting}

We can also demonstrate orthogonality.

\begin{lstlisting}[language=R]
> eig.vectors * t(eig.vectors)

     [,1] [,2]
[1,]    1    0
[2,]    0    1
\end{lstlisting}



% \chapter{Problem 4}
% \begin{figure}[h]
%  \begin{center}
% <<Problem4, echo=FALSE, quiet=TRUE, results=tex, fig=TRUE>>=
% 
% #####
% # Problem 4:
% #You noticed that eruptions clearly fall into two categories, short and long. Let us say that short eruptions are all which have duration shorter than 3.1 minute. 
% #1 - Add a new column to data frame faithful called type, which would have value ‘short’ for all short eruptions and value ‘long’ for all long eruptions. 
% #2 - Next use boxplot() function to provide your readers with some basic statistical measures for waiting. 
% #3 - In a separate plot present the box plot for duration times. Please note that boxplot() function also accepts as its first argument a formula such as waiting ~ type, where waiting is the numeric vector of data values to be split in groups according to the grouping variable type. The second argument of function boxplot() is called data, which in our case will take the name of our dataset, i.e. faithful. 
% #4 - Find a way to add meaningful legends to your graphs. Subsequently, present both boxplots on one graph.
% 
% #####
% # Code:
% 
% df <- faithful
% df$Length <- NA
% df[which(df$eruptions<3.1),"Length"] <- "Short"
% df[which(df$eruptions>3.1),"Length"] <- "Long"
% 
% p1 <- ggplot(data=df, aes(x=Length, y = waiting))+
%   geom_boxplot(aes(fill =Length)) 
% p2 <- ggplot(data=df, aes(x=Length, y = eruptions))+
%   geom_boxplot(aes(fill =Length))
%   
% grid.arrange(p1,p2)
% 
% 
% @
%   \caption{Question 4, Faithful Boxplots}
%  \end{center}
% \end{figure}
% 
% 
% 
% \chapter{Problem 5}
% \begin{figure}[h]
%  \begin{center}
% <<Problem5, echo=FALSE, quiet=TRUE, results=tex, fig=TRUE>>=
% 
% #####
% # Problem 5. 
% 
% ####
% # Question:
% #Create a matrix with 40 columns and 100 rows. 
% #Populate each column with random variable of the uniform distribution type. 
% #Make those distributions symmetric around zero. 
% #Let the distribution for each column appear like the one on slide 92 of the lecture note, except centered around zero.  
% #Present two distributions contained in any two randomly selected columns of your matrix on two separate plots. Convince yourself that generated distributions are (close to) uniform.
% 
% #####
% # Code:
% 
% df <- matrix(nrow = 100, ncol=40)
% for(i in 1:ncol(df)){
%   df[,i] <-runif(nrow(df),min=-1,max=1)
% }
% 
% df <-data.frame(df)
% colnames(df)[1:3] <- c("One", "Two", "Three")
% 
% # p1 <- ggplot()+
% #   geom_boxplot(aes(df$One)) 
% # p2 <- ggplot(data=df, aes(x=Length, y = eruptions))+
% #   geom_boxplot(aes(fill =Length))
% #   
% # grid.arrange(p1,p2)
% 
% plot(1:3,c(1:3))
% @
%   \caption{Question 5, Uniform Distribution}
%  \end{center}
% \end{figure}


%%%%
\end{document}